// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "http://localhost:4466"
var Secret = ""

func (client *Client) Token(params TokenWhereUniqueInput) *TokenExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"TokenWhereUniqueInput!", "Token"},
		"token",
		[]string{"id", "type"})

	return &TokenExec{ret}
}

type TokensParams struct {
	Where   *TokenWhereInput   `json:"where,omitempty"`
	OrderBy *TokenOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) Tokens(params *TokensParams) *TokenExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"TokenWhereInput", "TokenOrderByInput", "Token"},
		"tokens",
		[]string{"id", "type"})

	return &TokenExecArray{ret}
}

type TokensConnectionParams struct {
	Where   *TokenWhereInput   `json:"where,omitempty"`
	OrderBy *TokenOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) TokensConnection(params *TokensConnectionParams) TokenConnectionExec {
	panic("not implemented")
}

func (client *Client) User(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"user",
		[]string{"id", "username", "password"})

	return &UserExec{ret}
}

type UsersParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Users(params *UsersParams) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"users",
		[]string{"id", "username", "password"})

	return &UserExecArray{ret}
}

type UsersConnectionParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) UsersConnection(params *UsersConnectionParams) UserConnectionExec {
	panic("not implemented")
}

func (client *Client) CreateToken(params TokenCreateInput) *TokenExec {
	ret := client.Client.Create(
		params,
		[2]string{"TokenCreateInput!", "Token"},
		"createToken",
		[]string{"id", "type"})

	return &TokenExec{ret}
}

type TokenUpdateParams struct {
	Data  TokenUpdateInput      `json:"data"`
	Where TokenWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateToken(params TokenUpdateParams) *TokenExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"TokenUpdateInput!", "TokenWhereUniqueInput!", "Token"},
		"updateToken",
		[]string{"id", "type"})

	return &TokenExec{ret}
}

type TokenUpdateManyParams struct {
	Data  TokenUpdateManyMutationInput `json:"data"`
	Where *TokenWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyTokens(params TokenUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"TokenUpdateManyMutationInput!", "TokenWhereInput"},
		"updateManyTokens")
	return &BatchPayloadExec{exec}
}

type TokenUpsertParams struct {
	Where  TokenWhereUniqueInput `json:"where"`
	Create TokenCreateInput      `json:"create"`
	Update TokenUpdateInput      `json:"update"`
}

func (client *Client) UpsertToken(params TokenUpsertParams) *TokenExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"TokenWhereUniqueInput!", "TokenCreateInput!", "TokenUpdateInput!", "Token"},
		"upsertToken",
		[]string{"id", "type"})

	return &TokenExec{ret}
}

func (client *Client) DeleteToken(params TokenWhereUniqueInput) *TokenExec {
	ret := client.Client.Delete(
		params,
		[2]string{"TokenWhereUniqueInput!", "Token"},
		"deleteToken",
		[]string{"id", "type"})

	return &TokenExec{ret}
}

func (client *Client) DeleteManyTokens(params *TokenWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "TokenWhereInput", "deleteManyTokens")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateUser(params UserCreateInput) *UserExec {
	ret := client.Client.Create(
		params,
		[2]string{"UserCreateInput!", "User"},
		"createUser",
		[]string{"id", "username", "password"})

	return &UserExec{ret}
}

type UserUpdateParams struct {
	Data  UserUpdateInput      `json:"data"`
	Where UserWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateUser(params UserUpdateParams) *UserExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"UserUpdateInput!", "UserWhereUniqueInput!", "User"},
		"updateUser",
		[]string{"id", "username", "password"})

	return &UserExec{ret}
}

type UserUpdateManyParams struct {
	Data  UserUpdateManyMutationInput `json:"data"`
	Where *UserWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyUsers(params UserUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"UserUpdateManyMutationInput!", "UserWhereInput"},
		"updateManyUsers")
	return &BatchPayloadExec{exec}
}

type UserUpsertParams struct {
	Where  UserWhereUniqueInput `json:"where"`
	Create UserCreateInput      `json:"create"`
	Update UserUpdateInput      `json:"update"`
}

func (client *Client) UpsertUser(params UserUpsertParams) *UserExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"UserWhereUniqueInput!", "UserCreateInput!", "UserUpdateInput!", "User"},
		"upsertUser",
		[]string{"id", "username", "password"})

	return &UserExec{ret}
}

func (client *Client) DeleteUser(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.Delete(
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"deleteUser",
		[]string{"id", "username", "password"})

	return &UserExec{ret}
}

func (client *Client) DeleteManyUsers(params *UserWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "UserWhereInput", "deleteManyUsers")
	return &BatchPayloadExec{exec}
}

type TokenType string

const (
	TokenTypeActivation  TokenType = "Activation"
	TokenTypeResetPw     TokenType = "ResetPW"
	TokenTypeChangeEmail TokenType = "ChangeEmail"
	TokenTypeChangePw    TokenType = "ChangePW"
)

type TokenOrderByInput string

const (
	TokenOrderByInputIDAsc         TokenOrderByInput = "id_ASC"
	TokenOrderByInputIDDesc        TokenOrderByInput = "id_DESC"
	TokenOrderByInputTypeAsc       TokenOrderByInput = "type_ASC"
	TokenOrderByInputTypeDesc      TokenOrderByInput = "type_DESC"
	TokenOrderByInputCreatedAtAsc  TokenOrderByInput = "createdAt_ASC"
	TokenOrderByInputCreatedAtDesc TokenOrderByInput = "createdAt_DESC"
	TokenOrderByInputUpdatedAtAsc  TokenOrderByInput = "updatedAt_ASC"
	TokenOrderByInputUpdatedAtDesc TokenOrderByInput = "updatedAt_DESC"
)

type UserOrderByInput string

const (
	UserOrderByInputIDAsc         UserOrderByInput = "id_ASC"
	UserOrderByInputIDDesc        UserOrderByInput = "id_DESC"
	UserOrderByInputUsernameAsc   UserOrderByInput = "username_ASC"
	UserOrderByInputUsernameDesc  UserOrderByInput = "username_DESC"
	UserOrderByInputPasswordAsc   UserOrderByInput = "password_ASC"
	UserOrderByInputPasswordDesc  UserOrderByInput = "password_DESC"
	UserOrderByInputCreatedAtAsc  UserOrderByInput = "createdAt_ASC"
	UserOrderByInputCreatedAtDesc UserOrderByInput = "createdAt_DESC"
	UserOrderByInputUpdatedAtAsc  UserOrderByInput = "updatedAt_ASC"
	UserOrderByInputUpdatedAtDesc UserOrderByInput = "updatedAt_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type TokenWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type TokenWhereInput struct {
	ID              *string           `json:"id,omitempty"`
	IDNot           *string           `json:"id_not,omitempty"`
	IDIn            []string          `json:"id_in,omitempty"`
	IDNotIn         []string          `json:"id_not_in,omitempty"`
	IDLt            *string           `json:"id_lt,omitempty"`
	IDLte           *string           `json:"id_lte,omitempty"`
	IDGt            *string           `json:"id_gt,omitempty"`
	IDGte           *string           `json:"id_gte,omitempty"`
	IDContains      *string           `json:"id_contains,omitempty"`
	IDNotContains   *string           `json:"id_not_contains,omitempty"`
	IDStartsWith    *string           `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string           `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string           `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string           `json:"id_not_ends_with,omitempty"`
	User            *UserWhereInput   `json:"user,omitempty"`
	Type            *TokenType        `json:"type,omitempty"`
	TypeNot         *TokenType        `json:"type_not,omitempty"`
	TypeIn          []TokenType       `json:"type_in,omitempty"`
	TypeNotIn       []TokenType       `json:"type_not_in,omitempty"`
	And             []TokenWhereInput `json:"AND,omitempty"`
	Or              []TokenWhereInput `json:"OR,omitempty"`
	Not             []TokenWhereInput `json:"NOT,omitempty"`
}

type UserWhereInput struct {
	ID                    *string          `json:"id,omitempty"`
	IDNot                 *string          `json:"id_not,omitempty"`
	IDIn                  []string         `json:"id_in,omitempty"`
	IDNotIn               []string         `json:"id_not_in,omitempty"`
	IDLt                  *string          `json:"id_lt,omitempty"`
	IDLte                 *string          `json:"id_lte,omitempty"`
	IDGt                  *string          `json:"id_gt,omitempty"`
	IDGte                 *string          `json:"id_gte,omitempty"`
	IDContains            *string          `json:"id_contains,omitempty"`
	IDNotContains         *string          `json:"id_not_contains,omitempty"`
	IDStartsWith          *string          `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string          `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string          `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string          `json:"id_not_ends_with,omitempty"`
	Username              *string          `json:"username,omitempty"`
	UsernameNot           *string          `json:"username_not,omitempty"`
	UsernameIn            []string         `json:"username_in,omitempty"`
	UsernameNotIn         []string         `json:"username_not_in,omitempty"`
	UsernameLt            *string          `json:"username_lt,omitempty"`
	UsernameLte           *string          `json:"username_lte,omitempty"`
	UsernameGt            *string          `json:"username_gt,omitempty"`
	UsernameGte           *string          `json:"username_gte,omitempty"`
	UsernameContains      *string          `json:"username_contains,omitempty"`
	UsernameNotContains   *string          `json:"username_not_contains,omitempty"`
	UsernameStartsWith    *string          `json:"username_starts_with,omitempty"`
	UsernameNotStartsWith *string          `json:"username_not_starts_with,omitempty"`
	UsernameEndsWith      *string          `json:"username_ends_with,omitempty"`
	UsernameNotEndsWith   *string          `json:"username_not_ends_with,omitempty"`
	Password              *string          `json:"password,omitempty"`
	PasswordNot           *string          `json:"password_not,omitempty"`
	PasswordIn            []string         `json:"password_in,omitempty"`
	PasswordNotIn         []string         `json:"password_not_in,omitempty"`
	PasswordLt            *string          `json:"password_lt,omitempty"`
	PasswordLte           *string          `json:"password_lte,omitempty"`
	PasswordGt            *string          `json:"password_gt,omitempty"`
	PasswordGte           *string          `json:"password_gte,omitempty"`
	PasswordContains      *string          `json:"password_contains,omitempty"`
	PasswordNotContains   *string          `json:"password_not_contains,omitempty"`
	PasswordStartsWith    *string          `json:"password_starts_with,omitempty"`
	PasswordNotStartsWith *string          `json:"password_not_starts_with,omitempty"`
	PasswordEndsWith      *string          `json:"password_ends_with,omitempty"`
	PasswordNotEndsWith   *string          `json:"password_not_ends_with,omitempty"`
	TokensEvery           *TokenWhereInput `json:"tokens_every,omitempty"`
	TokensSome            *TokenWhereInput `json:"tokens_some,omitempty"`
	TokensNone            *TokenWhereInput `json:"tokens_none,omitempty"`
	And                   []UserWhereInput `json:"AND,omitempty"`
	Or                    []UserWhereInput `json:"OR,omitempty"`
	Not                   []UserWhereInput `json:"NOT,omitempty"`
}

type UserWhereUniqueInput struct {
	ID       *string `json:"id,omitempty"`
	Username *string `json:"username,omitempty"`
}

type TokenCreateInput struct {
	ID   *string                         `json:"id,omitempty"`
	User UserCreateOneWithoutTokensInput `json:"user"`
	Type TokenType                       `json:"type"`
}

type UserCreateOneWithoutTokensInput struct {
	Create  *UserCreateWithoutTokensInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput         `json:"connect,omitempty"`
}

type UserCreateWithoutTokensInput struct {
	ID       *string `json:"id,omitempty"`
	Username string  `json:"username"`
	Password string  `json:"password"`
}

type TokenUpdateInput struct {
	User *UserUpdateOneRequiredWithoutTokensInput `json:"user,omitempty"`
	Type *TokenType                               `json:"type,omitempty"`
}

type UserUpdateOneRequiredWithoutTokensInput struct {
	Create  *UserCreateWithoutTokensInput     `json:"create,omitempty"`
	Update  *UserUpdateWithoutTokensDataInput `json:"update,omitempty"`
	Upsert  *UserUpsertWithoutTokensInput     `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput             `json:"connect,omitempty"`
}

type UserUpdateWithoutTokensDataInput struct {
	Username *string `json:"username,omitempty"`
	Password *string `json:"password,omitempty"`
}

type UserUpsertWithoutTokensInput struct {
	Update UserUpdateWithoutTokensDataInput `json:"update"`
	Create UserCreateWithoutTokensInput     `json:"create"`
}

type TokenUpdateManyMutationInput struct {
	Type *TokenType `json:"type,omitempty"`
}

type UserCreateInput struct {
	ID       *string                          `json:"id,omitempty"`
	Username string                           `json:"username"`
	Password string                           `json:"password"`
	Tokens   *TokenCreateManyWithoutUserInput `json:"tokens,omitempty"`
}

type TokenCreateManyWithoutUserInput struct {
	Create  []TokenCreateWithoutUserInput `json:"create,omitempty"`
	Connect []TokenWhereUniqueInput       `json:"connect,omitempty"`
}

type TokenCreateWithoutUserInput struct {
	ID   *string   `json:"id,omitempty"`
	Type TokenType `json:"type"`
}

type UserUpdateInput struct {
	Username *string                          `json:"username,omitempty"`
	Password *string                          `json:"password,omitempty"`
	Tokens   *TokenUpdateManyWithoutUserInput `json:"tokens,omitempty"`
}

type TokenUpdateManyWithoutUserInput struct {
	Create     []TokenCreateWithoutUserInput                `json:"create,omitempty"`
	Delete     []TokenWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []TokenWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []TokenWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []TokenWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []TokenUpdateWithWhereUniqueWithoutUserInput `json:"update,omitempty"`
	Upsert     []TokenUpsertWithWhereUniqueWithoutUserInput `json:"upsert,omitempty"`
	DeleteMany []TokenScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []TokenUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type TokenUpdateWithWhereUniqueWithoutUserInput struct {
	Where TokenWhereUniqueInput           `json:"where"`
	Data  TokenUpdateWithoutUserDataInput `json:"data"`
}

type TokenUpdateWithoutUserDataInput struct {
	Type *TokenType `json:"type,omitempty"`
}

type TokenUpsertWithWhereUniqueWithoutUserInput struct {
	Where  TokenWhereUniqueInput           `json:"where"`
	Update TokenUpdateWithoutUserDataInput `json:"update"`
	Create TokenCreateWithoutUserInput     `json:"create"`
}

type TokenScalarWhereInput struct {
	ID              *string                 `json:"id,omitempty"`
	IDNot           *string                 `json:"id_not,omitempty"`
	IDIn            []string                `json:"id_in,omitempty"`
	IDNotIn         []string                `json:"id_not_in,omitempty"`
	IDLt            *string                 `json:"id_lt,omitempty"`
	IDLte           *string                 `json:"id_lte,omitempty"`
	IDGt            *string                 `json:"id_gt,omitempty"`
	IDGte           *string                 `json:"id_gte,omitempty"`
	IDContains      *string                 `json:"id_contains,omitempty"`
	IDNotContains   *string                 `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                 `json:"id_not_ends_with,omitempty"`
	Type            *TokenType              `json:"type,omitempty"`
	TypeNot         *TokenType              `json:"type_not,omitempty"`
	TypeIn          []TokenType             `json:"type_in,omitempty"`
	TypeNotIn       []TokenType             `json:"type_not_in,omitempty"`
	And             []TokenScalarWhereInput `json:"AND,omitempty"`
	Or              []TokenScalarWhereInput `json:"OR,omitempty"`
	Not             []TokenScalarWhereInput `json:"NOT,omitempty"`
}

type TokenUpdateManyWithWhereNestedInput struct {
	Where TokenScalarWhereInput    `json:"where"`
	Data  TokenUpdateManyDataInput `json:"data"`
}

type TokenUpdateManyDataInput struct {
	Type *TokenType `json:"type,omitempty"`
}

type UserUpdateManyMutationInput struct {
	Username *string `json:"username,omitempty"`
	Password *string `json:"password,omitempty"`
}

type TokenSubscriptionWhereInput struct {
	MutationIn                 []MutationType                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *TokenWhereInput              `json:"node,omitempty"`
	And                        []TokenSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []TokenSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []TokenSubscriptionWhereInput `json:"NOT,omitempty"`
}

type UserSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *UserWhereInput              `json:"node,omitempty"`
	And                        []UserSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []UserSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []UserSubscriptionWhereInput `json:"NOT,omitempty"`
}

type TokenExec struct {
	exec *prisma.Exec
}

func (instance *TokenExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "username", "password"})

	return &UserExec{ret}
}

func (instance TokenExec) Exec(ctx context.Context) (*Token, error) {
	var v Token
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TokenExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TokenExecArray struct {
	exec *prisma.Exec
}

func (instance TokenExecArray) Exec(ctx context.Context) ([]Token, error) {
	var v []Token
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Token struct {
	ID   string    `json:"id"`
	Type TokenType `json:"type"`
}

type UserExec struct {
	exec *prisma.Exec
}

type TokensParamsExec struct {
	Where   *TokenWhereInput
	OrderBy *TokenOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) Tokens(params *TokensParamsExec) *TokenExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"TokenWhereInput", "TokenOrderByInput", "Token"},
		"tokens",
		[]string{"id", "type"})

	return &TokenExecArray{ret}
}

func (instance UserExec) Exec(ctx context.Context) (*User, error) {
	var v User
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserExecArray struct {
	exec *prisma.Exec
}

func (instance UserExecArray) Exec(ctx context.Context) ([]User, error) {
	var v []User
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type User struct {
	ID       string `json:"id"`
	Username string `json:"username"`
	Password string `json:"password"`
}

type TokenConnectionExec struct {
	exec *prisma.Exec
}

func (instance *TokenConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *TokenConnectionExec) Edges() *TokenEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TokenEdge"},
		"edges",
		[]string{"cursor"})

	return &TokenEdgeExec{ret}
}

func (instance *TokenConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateToken"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance TokenConnectionExec) Exec(ctx context.Context) (*TokenConnection, error) {
	var v TokenConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TokenConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TokenConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance TokenConnectionExecArray) Exec(ctx context.Context) ([]TokenConnection, error) {
	var v []TokenConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TokenConnection struct {
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type TokenEdgeExec struct {
	exec *prisma.Exec
}

func (instance *TokenEdgeExec) Node() *TokenExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Token"},
		"node",
		[]string{"id", "type"})

	return &TokenExec{ret}
}

func (instance TokenEdgeExec) Exec(ctx context.Context) (*TokenEdge, error) {
	var v TokenEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TokenEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TokenEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance TokenEdgeExecArray) Exec(ctx context.Context) ([]TokenEdge, error) {
	var v []TokenEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TokenEdge struct {
	Cursor string `json:"cursor"`
}

type UserConnectionExec struct {
	exec *prisma.Exec
}

func (instance *UserConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *UserConnectionExec) Edges() *UserEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserEdge"},
		"edges",
		[]string{"cursor"})

	return &UserEdgeExec{ret}
}

func (instance *UserConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateUser"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance UserConnectionExec) Exec(ctx context.Context) (*UserConnection, error) {
	var v UserConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance UserConnectionExecArray) Exec(ctx context.Context) ([]UserConnection, error) {
	var v []UserConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserConnection struct {
}

type UserEdgeExec struct {
	exec *prisma.Exec
}

func (instance *UserEdgeExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "username", "password"})

	return &UserExec{ret}
}

func (instance UserEdgeExec) Exec(ctx context.Context) (*UserEdge, error) {
	var v UserEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance UserEdgeExecArray) Exec(ctx context.Context) ([]UserEdge, error) {
	var v []UserEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserEdge struct {
	Cursor string `json:"cursor"`
}

type TokenSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *TokenSubscriptionPayloadExec) Node() *TokenExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Token"},
		"node",
		[]string{"id", "type"})

	return &TokenExec{ret}
}

func (instance *TokenSubscriptionPayloadExec) PreviousValues() *TokenPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TokenPreviousValues"},
		"previousValues",
		[]string{"id", "type"})

	return &TokenPreviousValuesExec{ret}
}

func (instance TokenSubscriptionPayloadExec) Exec(ctx context.Context) (*TokenSubscriptionPayload, error) {
	var v TokenSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TokenSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TokenSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance TokenSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]TokenSubscriptionPayload, error) {
	var v []TokenSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TokenSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type TokenPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance TokenPreviousValuesExec) Exec(ctx context.Context) (*TokenPreviousValues, error) {
	var v TokenPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TokenPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TokenPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance TokenPreviousValuesExecArray) Exec(ctx context.Context) ([]TokenPreviousValues, error) {
	var v []TokenPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TokenPreviousValues struct {
	ID   string    `json:"id"`
	Type TokenType `json:"type"`
}

type UserSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *UserSubscriptionPayloadExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "username", "password"})

	return &UserExec{ret}
}

func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserPreviousValues"},
		"previousValues",
		[]string{"id", "username", "password"})

	return &UserPreviousValuesExec{ret}
}

func (instance UserSubscriptionPayloadExec) Exec(ctx context.Context) (*UserSubscriptionPayload, error) {
	var v UserSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance UserSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UserSubscriptionPayload, error) {
	var v []UserSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type UserPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExec) Exec(ctx context.Context) (*UserPreviousValues, error) {
	var v UserPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExecArray) Exec(ctx context.Context) ([]UserPreviousValues, error) {
	var v []UserPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserPreviousValues struct {
	ID       string `json:"id"`
	Username string `json:"username"`
	Password string `json:"password"`
}
